# myCppStudy
myCppStudy

---------------------------------
* C++基础：
* √ 1、lambda表达式匹配用
* √ 2、构造方式
* √ 3、移动赋值
---------------------------------
* 常用设计模式学习
* 以下是一些C++中常用的设计模式：
* √ 1.单例模式 (Singleton Pattern): 当一个类只能创建一个对象，并且提供一个全局访问点来访问这个对象时，可以使用单例模式。这在需要频繁访问或配置某些资源或功能时非常有用，例如日志记录器或配置管理器。
* √ 2.工厂模式 (Factory Pattern): 当需要创建一系列相关或依赖对象，而不希望指定具体的类时，可以使用工厂模式。工厂模式通过抽象创建过程来隐藏具体的实现细节，使得代码更加灵活和可扩展。
* 3.观察者模式 (Observer Pattern): 当一个对象的状态发生改变时，需要通知其他依赖它的对象时，可以使用观察者模式。这种模式实现了发布-订阅机制，使得对象之间可以松耦合地通信。
* 4.策略模式 (Strategy Pattern): 当有多种算法或行为，并且这些算法或行为可以在运行时动态地改变时，可以使用策略模式。策略模式定义了一系列可以互相替换的算法，使得算法独立于使用它的客户端。
* 5.状态模式 (State Pattern): 当一个对象的行为取决于它的内部状态时，可以使用状态模式。状态模式将行为封装在不同的状态类中，并通过状态对象来管理这些行为，使得对象在内部状态改变时表现出不同的行为。
* 6.装饰器模式 (Decorator Pattern): 当需要动态地给一个对象添加一些额外的职责，并且希望这些职责可以被灵活地添加和撤销时，可以使用装饰器模式。装饰器模式通过包装对象来添加功能，而不是通过继承。
* 7.适配器模式 (Adapter Pattern): 当需要将一个类的接口转换成客户端期望的另一个接口时，可以使用适配器模式。适配器模式使得原本不兼容的类可以一起工作。
* 8.模板方法模式 (Template Method Pattern): 当一个方法中的某些步骤是固定的，而某些步骤是可变的，并且这些步骤需要在子类中实现时，可以使用模板方法模式。这种模式在算法框架中非常有用，可以确保算法的关键步骤按照预期的顺序执行。
---------------------------------
---------------------------------
提交日志：

---------------------------------
* 20240601-1
1、修改拷贝构造成员
2、增加移动构造
3、增加移动赋值相关内容

BTW:本工程暂时不更新，因为突然发现基础十分薄弱，换个工程去做一些基础的学习

---------------------------------
* 20240531-1
1、调整README.md的内容
2、新增构造部分的内容
3、新增默认构造和拷贝构造

---------------------------------
* 20240530-4
1、修复编译失败的问题

---------------------------------
* 20240530-3
1、维护单例模式，添加禁止拷贝构造和禁止拷贝赋

---------------------------------
* 20240530-2
1、单例模式是没有问题的，我错把指针的地址进行了比较，当然不同了
2、新建了公共头文件
3、将lambda表达式相关的内容从main.cpp中抽出来，为后续学习更多lambda的内容做铺垫

---------------------------------
* 20240530-1
1、完成工厂模式，工厂采用了单例的形
2、发现单例模式是有问题的，生成的单例是两个不同的指针，待排查

---------------------------------
* 20240529
1、新增工厂模式代码
2、但是没有完成，仍有一些错误，需要修正

---------------------------------
* 20240526-2
1、新增回顾时出的错误及分析
2、新增lambda表达式的相关学习内容

---------------------------------
* 20240526-1
1、新增智能指针管理的单例模式

---------------------------------
* 20240525
1、新建工程
2、新增单例模式例子

---------------------------------